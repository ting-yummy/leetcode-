package com.jdt.leetcode.simple;

/**
 * 70. 爬楼梯
 * 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
 * <p>
 * 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
 * <p>
 * <p>
 * <p>
 * 示例 1：
 * <p>
 * 输入：n = 2
 * 输出：2
 * 解释：有两种方法可以爬到楼顶。
 * 1. 1 阶 + 1 阶
 * 2. 2 阶
 * 示例 2：
 * <p>
 * 输入：n = 3
 * 输出：3
 * 解释：有三种方法可以爬到楼顶。
 * 1. 1 阶 + 1 阶 + 1 阶
 * 2. 1 阶 + 2 阶
 * 3. 2 阶 + 1 阶
 * <p>
 * <p>
 * 提示：
 * <p>
 * 1 <= n <= 45
 *
 * @author jdt
 * @date 2023/8/17
 */
public class Solution70 {
    /**
     * 由于题目要求只能迈一阶或者两阶 所以要想达到只有两种可能性从n-1点迈一步到终点, 或者从n-2点迈两步到达终点
     *
     * 假设从起点到 n-1点有 f(n-1)种方案, 那么从起点点到终点就会有f(n-1) * 1种方案.
     * 因为n-1点到终点只有一种方案, 从起点到n-1点的每种方案和最后一种方案结合会形成新的f(n-1) * 1种方案
     *
     * 同理: 从n-2走一步到终点只有一种方案. 注意这里说的是从n-2直达到终点只有一种方案,
     * 我们只考虑直达的 方案. 那么从起点到n-2点的每种方案会和n-2直达终点形成新的f(n-2) * 1种方案
     *
     * 还有一点要注意的是: 上述和新形成的f(n-1)种方案和新形成的f(n-2)种方案是完全不同的 f(n-1)是和n-1点 -->终点集合形成的,
     * f(n-2)是和n-2 --> 终点结合形成的, 他们每一种方案都不同
     *
     * 说完了这些, 再来看看问题咋解把: 根据题意:
     *
     * 因为一次只能走一步或者两步, 所以一定会经过n-1和n-2点其中的一个.
     * 从起点到终点的路径数等于"从起点经过n-1点直达终点的路径数"和"从起点经过n-2点直达终点的路径数"
     * 又因为经过n-1直达终点的路径数为f(n-1), 直达n-2点直达终点为f(n-2)个, 其中并没有重叠的路线.
     * 所以 fn(n) = f(n-1)+f(n-2)
     * @param n
     * @return
     */
    public static int climbStairs(int n) {
        int[] dep = new int[n+1];
        dep[0] = 1;
        dep[1] = 1;
        for (int i = 2; i <= n; i++) {
            dep[i] = dep[i - 1] + dep[i - 2];
        }
        return dep[n];

    }

    public static void main(String[] args) {
        System.out.println(climbStairs(4));
    }
}
